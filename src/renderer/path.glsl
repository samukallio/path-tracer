#version 450

#define DECLARE_FRAME_UBO_BINDING
#define DECLARE_COMPUTE_BINDINGS
#define DECLARE_SCENE_BINDINGS
#include "common.glsl.inc"

layout(local_size_x=16, local_size_y=16, local_size_z=1) in;

// Generate a random direction from the skybox directional distribution such
// that the generated direction lies in the hemisphere corresponding to the
// given normal.  The strategy is to sample a random direction first, then
// flip the direction if it lies in the wrong hemisphere.  A more "correct"
// approach would be to do rejection sampling to sample from the probability
// distribution conditioned on the direction lying in the correct hemisphere,
// but that is less efficient and makes determining the resulting probability
// density difficult.
vec3 RandomHemisphereSkyboxDirection(vec3 Normal)
{
    vec3 Direction = Scene.SkyboxDistributionFrame * RandomVonMisesFisher(Scene.SkyboxDistributionConcentration);
    return dot(Direction, Normal) < 0 ? -Direction : Direction;
}

// Return the probability density of a direction generated by the
// RandomHemisphereSkyboxDirection function.
float HemisphereSkyboxDirectionPDF(vec3 Direction)
{
    float Kappa = Scene.SkyboxDistributionConcentration;
    vec3 Mu = Scene.SkyboxDistributionFrame[2];

    // The probability density is the sum of the von Mises-Fisher densities
    // of the given direction and its opposite, since both map to the same
    // output direction as per the procedure outlined above.
    float C = Kappa / (2 * TAU * sinh(Kappa));
    float Z = Kappa * dot(Mu, Direction);
    return C * (exp(Z) + exp(-Z));
}

vec4 SampleTexture(uint Index, vec2 UV)
{
    packed_texture Texture = Textures[Index];

    float U = mix(
        Texture.AtlasPlacementMinimum.x,
        Texture.AtlasPlacementMaximum.x,
        fract(UV.x));

    float V = mix(
        Texture.AtlasPlacementMinimum.y,
        Texture.AtlasPlacementMaximum.y,
        fract(UV.y));

    vec3 UVW = vec3(U, V, Texture.AtlasImageIndex);

    if ((Texture.Flags & TEXTURE_FLAG_FILTER_NEAREST) != 0)
        return textureLod(TextureArrayNearest, UVW, 0);
    else
        return textureLod(TextureArrayLinear, UVW, 0);
}

vec4 SampleSkyboxSpectrum(ray Ray)
{
//    mat3 frame = skyboxDistributionFrame;
//    float x = (1 + dot(Ray.Vector, frame[0])) / 2.0;
//    float y = (1 + dot(Ray.Vector, frame[1])) / 2.0;
//    float z = (1 + dot(Ray.Vector, frame[2])) / 2.0;
//    return vec3(x, y, z);

    if (Scene.SkyboxTextureIndex == TEXTURE_INDEX_NONE)
        return vec4(0, 0, 100, 1);

    float Phi = atan(Ray.Vector.y, Ray.Vector.x);
    float Theta = asin(Ray.Vector.z);

    float U = 0.5 + Phi / TAU;
    float V = 0.5 + Theta / PI;

    return SampleTexture(Scene.SkyboxTextureIndex, vec2(U, V));
}

vec4 SampleSkyboxRadiance(ray Ray, vec4 Lambda)
{
    vec4 Spectrum = SampleSkyboxSpectrum(Ray);
    return SampleParametricSpectrum(Spectrum, Lambda) * Scene.SkyboxBrightness;
}

void GenerateNewPath(uint Index, ivec2 ImagePosition)
{
    ivec2 ImageSize = imageSize(SampleAccumulatorImage);

    // Compute the position of the sample we are going to produce in image
    // coordinates from (0, 0) to (ImageSizeX, ImageSizeY).
    vec2 SamplePosition = ImagePosition;

    if ((RenderFlags & RENDER_FLAG_SAMPLE_JITTER) != 0)
        SamplePosition += vec2(Random0To1(), Random0To1());
    else
        SamplePosition += vec2(0.5, 0.5);

    // Compute normalized sample position from (0, 0) to (1, 1).
    vec2 NormalizedSamplePosition = SamplePosition / ImageSize;

    ray Ray;

    Ray.Duration = INFINITY;

    if (CameraModel == CAMERA_MODEL_PINHOLE) {
        vec3 SensorPosition = vec3(
            -CameraSensorSize.x * (NormalizedSamplePosition.x - 0.5),
            -CameraSensorSize.y * (0.5 - NormalizedSamplePosition.y),
            CameraSensorDistance);

        Ray.Origin = vec3(CameraApertureRadius * RandomPointOnDisk(), 0);
        Ray.Vector = normalize(Ray.Origin - SensorPosition);
    }

    else if (CameraModel == CAMERA_MODEL_THIN_LENS) {
        vec3 SensorPosition = vec3(
            -CameraSensorSize.x * (NormalizedSamplePosition.x - 0.5),
            -CameraSensorSize.y * (0.5 - NormalizedSamplePosition.y),
            CameraSensorDistance);

        vec3 ObjectPosition = -SensorPosition * CameraFocalLength / (SensorPosition.z - CameraFocalLength);

        Ray.Origin = vec3(CameraApertureRadius * RandomPointOnDisk(), 0);
        Ray.Vector = normalize(ObjectPosition - Ray.Origin);
    }

    else if (CameraModel == CAMERA_MODEL_360) {
        float Phi = (NormalizedSamplePosition.x - 0.5f) * TAU;
        float Theta = (0.5f - NormalizedSamplePosition.y) * PI;

        Ray.Origin = vec3(0, 0, 0);
        Ray.Vector = vec3(cos(Theta) * sin(Phi), sin(Theta), -cos(Theta) * cos(Phi));
    }

    Ray = TransformRay(Ray, CameraTransform);

    // Write initial ray.
    StoreTraceRay(Index, Ray);

    // Write new path.
    path Path;
    Path.ImagePosition  = ImagePosition;

    float NormalizedLambda0 = Random0To1();
    Path.Lambda = vec4(
        mix(CIE_LAMBDA_MIN, CIE_LAMBDA_MAX,       NormalizedLambda0        ),
        mix(CIE_LAMBDA_MIN, CIE_LAMBDA_MAX, fract(NormalizedLambda0 + 0.25)),
        mix(CIE_LAMBDA_MIN, CIE_LAMBDA_MAX, fract(NormalizedLambda0 + 0.50)),
        mix(CIE_LAMBDA_MIN, CIE_LAMBDA_MAX, fract(NormalizedLambda0 + 0.75))
    );

    Path.Throughput     = vec4(1.0);
    Path.Weight         = vec4(1.0);
    Path.Sample         = vec3(0.0);

    StorePath(Index, Path);
}

/* --- BSDF ---------------------------------------------------------------- */

// Evaluate the surface properties of a hit surface at given wavelengths.
void ResolveSurfaceHit(hit Hit, vec4 Lambda, vec4 ExteriorIOR, out surface Surface, out medium Medium)
{
    packed_material Material = Materials[Hit.MaterialIndex];

    // Geometric opacity.
    Surface.Opacity = Material.Opacity;

    // Surface composition.
    Surface.CoatIsPresent = Random0To1() < Material.CoatWeight;
    Surface.BaseIsMetal = Random0To1() < Material.BaseMetalness;
    Surface.BaseIsTranslucent = !Surface.BaseIsMetal && Random0To1() < Material.TransmissionWeight;

    // Base reflectance and opacity.
    Surface.BaseReflectance = Material.BaseWeight * SampleParametricSpectrum(Material.BaseSpectrum, Lambda);
    Surface.BaseDiffuseRoughness = Material.BaseDiffuseRoughness;

    if (Material.BaseSpectrumTextureIndex != TEXTURE_INDEX_NONE) {
        vec4 Value = SampleTexture(Material.BaseSpectrumTextureIndex, Hit.UV);
        Surface.BaseReflectance *= SampleParametricSpectrum(Value.xyz, Lambda);
        Surface.Opacity *= Value.a;
    }

    // Coat.
    if (Surface.CoatIsPresent) {
        Surface.CoatRelativeIOR = ExteriorIOR / Material.CoatIOR;
        Surface.CoatTransmittance = SampleParametricSpectrum(Material.CoatColorSpectrum, Lambda);
        Surface.CoatRoughnessAlpha = GGXRoughnessAlpha(Material.CoatRoughness, Material.CoatRoughnessAnisotropy);
    }

    // Specular.
    Surface.SpecularWeight = Material.SpecularWeight;
    Surface.SpecularReflectance = SampleParametricSpectrum(Material.SpecularSpectrum, Lambda);

    float AbbeNumber = Material.TransmissionDispersionAbbeNumber / Material.TransmissionDispersionScale;
    vec4 SpecularIOR = CauchyEmpiricalIOR(Material.SpecularIOR, AbbeNumber, Lambda);

    if (Surface.CoatIsPresent)
        Surface.SpecularRelativeIOR = Material.CoatIOR / SpecularIOR;
    else
        Surface.SpecularRelativeIOR = ExteriorIOR / SpecularIOR;

    float SpecularRoughness = Material.SpecularRoughness;
    if (Material.SpecularRoughnessTextureIndex != TEXTURE_INDEX_NONE) {
        vec4 Value = SampleTexture(Material.SpecularRoughnessTextureIndex, Hit.UV);
        SpecularRoughness *= Value.r;
    }

    Surface.SpecularRoughnessAlpha = GGXRoughnessAlpha(
        SpecularRoughness,
        Material.SpecularRoughnessAnisotropy);

    //
    Surface.Emission = SampleParametricSpectrum(Material.EmissionSpectrum, Lambda) * Material.EmissionLuminance;
    if (Material.EmissionSpectrumTextureIndex != TEXTURE_INDEX_NONE) {
        vec4 Value = SampleTexture(Material.EmissionSpectrumTextureIndex, Hit.UV);
        Surface.Emission *= SampleParametricSpectrum(Value, Lambda);
    }

    //
    Surface.LayerBounceLimit = Material.LayerBounceLimit;

    // Medium.
    Medium.ShapeIndex = Hit.ShapeIndex;
    Medium.ShapePriority = Hit.ShapePriority;

    Medium.IOR = SpecularIOR;

    if (Material.TransmissionDepth > 0) {
        vec4 ExtinctionRate = -log(SampleParametricSpectrum(Material.TransmissionSpectrum, Lambda)) / Material.TransmissionDepth;
        vec4 ScatteringRate = SampleParametricSpectrum(Material.TransmissionScatterSpectrum, Lambda) / Material.TransmissionDepth;
        Medium.AbsorptionRate = max(ExtinctionRate - ScatteringRate, 0);
        Medium.ScatteringRate = ScatteringRate;
        Medium.ScatteringAnisotropy = Material.TransmissionScatterAnisotropy;
    }
    else {
        Medium.AbsorptionRate = vec4(0.0);
        Medium.ScatteringRate = vec4(0.0);
        Medium.ScatteringAnisotropy = 0.0;
    }
}

// OpenPBR coat BSDF.
void CoatBSDF(surface Surface, vec4 Lambda, vec3 Out, out vec3 In, inout path Path)
{
    if (!Surface.CoatIsPresent) {
        In = -Out;
        return;
    }

    // Sample a microsurface normal for coat scattering.
    float NormalU1 = Random0To1();
    float NormalU2 = Random0To1();
    vec3 Normal = GGXVisibleNormal(Out * sign(Out.z), Surface.CoatRoughnessAlpha, NormalU1, NormalU2);
    float Cosine = dot(Normal, Out);

    // Substrate is a dielectric.
    vec4 RelativeIOR = Surface.CoatRelativeIOR;
    if (Out.z < 0) RelativeIOR = 1.0 / RelativeIOR;

    // Compute the cosine of the angle between the refraction direction and
    // the microsurface normal.  The squared cosine is clamped to zero, the
    // boundary for total internal reflection (TIR).  When the cosine is zero,
    // the Fresnel formulas give a reflectivity of 1, producing a TIR without
    // the need for branches.
    float RefractedCosineSquared = 1 - RelativeIOR.x * RelativeIOR.x * (1 - Cosine * Cosine);
    float RefractedCosine = -sign(Out.z) * sqrt(max(RefractedCosineSquared, 0.0));

    // Compute dielectric reflectance.
    float Reflectance = FresnelDielectric(RefractedCosine, Cosine, RelativeIOR.x);

    // Specular reflection?
    if (Random0To1() < Reflectance) {
        // Compute reflected direction.
        In = 2 * Cosine * Normal - Out;

        // If the reflected direction is in the wrong hemisphere,
        // then it is shadowed and we terminate here.
        if (In.z * Out.z <= 0) {
            Path.Weight = vec4(0.0);
            return;
        }

        Path.Throughput *= GGXSmithG1(In, Surface.CoatRoughnessAlpha);

        // If the outgoing ray points down, then the ray is being reflected
        // within the coat medium.  Apply the coat absorption factor for both
        // the incoming and outgoing direction.  The path length of a ray
        // within the coat depends on the angle of the ray with respect to
        // the surface normal.  Here, the angle is measured with respect to
        // the macrosurface normal, as the thickness of the coat layer is
        // oriented along the macrosurface.
        if (Out.z < 0) {
            float Exponent = -(0.5 / Out.z + 0.5 / In.z);
            Path.Throughput *= pow(Surface.CoatTransmittance, vec4(Exponent));
        }
    }
    else {
        // Compute refracted direction.
        In = (RelativeIOR.x * Cosine + RefractedCosine) * Normal - RelativeIOR.x * Out;

        // If the refracted direction is in the wrong hemisphere,
        // then it is shadowed and we terminate here.
        if (In.z * Out.z > 0) {
            Path.Weight = vec4(0.0);
            return;
        }

        Path.Throughput *= GGXSmithG1(In, Surface.CoatRoughnessAlpha);

        // The ray is traversing the coat medium.  Apply the coat absorption
        // factor based on the distance traversed in the coat medium.  If the
        // outgoing ray points down, then it is the outgoing ray that passes
        // through the medium, and we determine the path length using that.
        // Otherwise, it is the incoming ray that traverses the medium.
        if (Out.z < 0)
            Path.Throughput *= pow(Surface.CoatTransmittance, vec4(-0.5 / Out.z));
        else
            Path.Throughput *= pow(Surface.CoatTransmittance, vec4(-0.5 / In.z));
    }
}

// Specular part of the OpenPBR base substrate BSDF.
void BaseSpecularBSDF(surface Surface, vec4 Lambda, vec3 Out, out vec3 In, inout path Path)
{
    if (Out.z > 0) AddEmission(Path, Surface.Emission);

    // Sample a microsurface normal for specular scattering.
    float NormalU1 = Random0To1();
    float NormalU2 = Random0To1();
    vec3 Normal = GGXVisibleNormal(Out * sign(Out.z), Surface.SpecularRoughnessAlpha, NormalU1, NormalU2);
    float Cosine = dot(Normal, Out);

    // Metal base substrate.
    if (Surface.BaseIsMetal) {
        // Compute reflected direction.
        In = 2 * Cosine * Normal - Out;

        // If the reflected direction is in the wrong hemisphere,
        // then it is shadowed and we terminate here.
        if (Out.z * In.z <= 0) {
            Path.Weight = vec4(0.0);
            return;
        }

        float Shadowing = GGXSmithG1(Out, Surface.SpecularRoughnessAlpha);

        vec4 Fresnel = Surface.SpecularWeight * SchlickFresnelMetal(
            Surface.BaseReflectance,
            Surface.SpecularReflectance,
            abs(Cosine));

        Path.Throughput *= Fresnel * Shadowing;
    }
    // Dielectric base substrate.
    else {
        vec4 RelativeIOR = Surface.SpecularRelativeIOR;
        if (Out.z < 0) RelativeIOR = 1.0 / RelativeIOR;

        // Modulation of the relative IOR by the specular weight parameter.
        if (Surface.SpecularWeight < 1.0) {
            vec4 R = sqrt(Surface.SpecularWeight) * (1.0 - RelativeIOR) / (1.0 + RelativeIOR);
            RelativeIOR = (1.0 - R) / (1.0 + R);
        }

        // Compute the cosine of the angle between the refraction direction and
        // the microsurface normal.  The squared cosine is clamped to zero, the
        // boundary for total internal reflection (TIR).  When the cosine is zero,
        // the Fresnel formulas give a reflectivity of 1, producing a TIR without
        // the need for branches.
        float RefractedCosineSquared = 1 - RelativeIOR.x * RelativeIOR.x * (1 - Cosine * Cosine);
        float RefractedCosine = -sign(Out.z) * sqrt(max(RefractedCosineSquared, 0.0));

        // Compute dielectric reflectance.
        float Reflectance = FresnelDielectric(RefractedCosine, Cosine, RelativeIOR.x);

        // Specular reflection?
        if (Random0To1() < Reflectance) {
            // Compute reflected direction.
            In = 2 * Cosine * Normal - Out;

            // If the reflected direction is in the wrong hemisphere,
            // then it is shadowed and we terminate here.
            if (In.z * Out.z <= 0) {
                Path.Weight = vec4(0.0);
                return;
            }

            // Per the OpenPBR specification: the specular color material
            // parameter modulates the Fresnel factor of the dielectric,
            // but only for reflections from above (and not below).
            if (Out.z > 0) Path.Throughput *= Surface.SpecularReflectance;

            Path.Throughput *= GGXSmithG1(In, Surface.SpecularRoughnessAlpha);
        }
        else {
            // Compute refracted direction.
            In = (RelativeIOR.x * Cosine + RefractedCosine) * Normal - RelativeIOR.x * Out;

            // If the refracted direction is in the wrong hemisphere,
            // then it is shadowed and we terminate here.
            if (In.z * Out.z > 0) {
                Path.Weight = vec4(0.0);
                return;
            }

            float Shadowing = GGXSmithG1(In, Surface.SpecularRoughnessAlpha);

            // If the surface is rough, then a refraction with the same incoming
            // and outgoing direction is possible for the secondary wavelengths,
            // although with different probabilities.
            if (length(Surface.SpecularRoughnessAlpha) > EPSILON) {
                // Compute the Fresnel terms for all wavelengths.
                vec4 Fresnel = FresnelDielectric(RefractedCosine, Cosine, RelativeIOR);

                // Compute the microfacet surface normals that would be necessary
                // to cause the same refraction to occur but for the secondary
                // wavelengths.  Note that the orientation of the normals might
                // be wrong, but it doesn't matter here, since GGXDistribution()
                // has reflection symmetry.
                vec3 Normal2 = SafeNormalize(In + Out * RelativeIOR.y);
                vec3 Normal3 = SafeNormalize(In + Out * RelativeIOR.z);
                vec3 Normal4 = SafeNormalize(In + Out * RelativeIOR.w);

                // Now figure out the GGX densities of the normals.
                vec4 Density = vec4(0.0);

                // Density of the normal corresponding to the primary wavelength.
                Density.x = GGXDistribution(Normal, Surface.SpecularRoughnessAlpha);

                // Densities for the secondary wavelengths.  We also need to check
                // that the generated normals are actually plausible (no total
                // internal reflection).  Otherwise, the refraction is impossible
                // and the corresponding density is zero.
                if (dot(In, Normal2) * dot(Out, Normal2) < 0.0)
                    Density.y = GGXDistribution(Normal2, Surface.SpecularRoughnessAlpha);
                if (dot(In, Normal3) * dot(Out, Normal3) < 0.0)
                    Density.z = GGXDistribution(Normal3, Surface.SpecularRoughnessAlpha);
                if (dot(In, Normal4) * dot(Out, Normal4) < 0.0)
                    Density.w = GGXDistribution(Normal4, Surface.SpecularRoughnessAlpha);

                // Scale the densities towards unity to mitigate numerical problems.
                Density /= max(EPSILON, max4(Density));

                Path.Throughput *= Density * Fresnel * Shadowing;
                Path.Weight *= Density * Fresnel;
            }
            else {
                // The surface is perfectly smooth, so the probability of generating
                // this refraction with any of the secondary wavelengths is zero.
                // We continue with just the primary wavelength.
                Path.Throughput.x *= Shadowing;
                Path.Throughput.yzw = vec3(0.0);
                Path.Weight.yzw = vec3(0.0);
            }
        }
    }
}

// Diffuse part of the OpenPBR base substrate BSDF.
void BaseDiffuseBSDF(surface Surface, vec4 Lambda, vec3 Out, out vec3 In, inout path Path)
{
    if (Surface.BaseIsTranslucent) {
        In = -Out;
        return;
    }

    In = SafeNormalize(RandomDirection() + vec3(0, 0, 1));

    float S = dot(In, Out) - In.z * Out.z;
    float T = S > 0 ? max(In.z, Out.z) : 1.0;
    float SigmaSq = Surface.BaseDiffuseRoughness * Surface.BaseDiffuseRoughness;
    vec4 A = 1 - 0.5 * SigmaSq / (SigmaSq + 0.33) + 0.17 * Surface.BaseReflectance * SigmaSq / (SigmaSq + 0.13);
    float B = 0.45 * SigmaSq / (SigmaSq + 0.09);

    Path.Throughput *= Surface.BaseReflectance * (A + B * S / T);
}

void BSDF(surface Surface, vec4 Lambda, vec3 Out, out vec3 In, inout path Path)
{
    const int LAYER_EXTERNAL = -1;
    const int LAYER_COAT = 0;
    const int LAYER_BASE_SPECULAR = 1;
    const int LAYER_BASE_DIFFUSE = 2;

    int Layer;
    
    if (Out.z > 0)
        Layer = Surface.CoatIsPresent ? LAYER_COAT : LAYER_BASE_SPECULAR;
    else
        Layer = LAYER_BASE_SPECULAR;

    for (int I = 0; I < Surface.LayerBounceLimit; I++) {
        if (Layer == LAYER_COAT) {
            CoatBSDF(Surface, Lambda, Out, In, Path);
            Layer = In.z < 0 ? LAYER_BASE_SPECULAR : LAYER_EXTERNAL;
        }
        else if (Layer == LAYER_BASE_SPECULAR) {
            BaseSpecularBSDF(Surface, Lambda, Out, In, Path);
            Layer = In.z < 0 ? LAYER_BASE_DIFFUSE : LAYER_COAT;
        }
        else if (Layer == LAYER_BASE_DIFFUSE) {
            BaseDiffuseBSDF(Surface, Lambda, Out, In, Path);
            Layer = In.z < 0 ? LAYER_EXTERNAL : LAYER_BASE_SPECULAR;
        }
        else if (Layer == LAYER_EXTERNAL) {
            break;
        }

        if (max4(Path.Weight) < EPSILON) break;

        Out = -In;
    }
}

void RenderPathTrace(inout path Path, inout ray Ray, hit Hit)
{
//    medium Ambience;
//    Ambience.ShapeIndex = SHAPE_INDEX_NONE;
//    Ambience.ShapePriority = 0;
//    Ambience.IOR = vec4(1.0);
//    Ambience.AbsorptionRate = vec4(0.0);
//    Ambience.ScatteringRate = vec4(SceneScatterRate);
//    Ambience.ScatteringAnisotropy = 0.0;

//    // Determine the highest-priority medium that we are currently
//    // in, and set it as the active one.
//    medium Medium = Ambience;
//    for (int I = 0; I < MAX_MEDIUM_COUNT; I++) {
//        if (Path.Mediums[I].ShapeIndex == SHAPE_INDEX_NONE)
//            continue;
//        if (Path.Mediums[I].ShapePriority < Medium.ShapePriority)
//            continue;
//        Medium = Path.Mediums[I];
//    }

//    float ScatteringTime = INFINITY;
//
//    Path.Throughput *= exp(-Medium.AbsorptionRate * Hit.Time);
//
//    // If we hit no geometry before the scattering time...
//    if (Hit.Time == ScatteringTime) {
//        // If the scattering time is finite, then it's a scattering event.
//        if (ScatteringTime < INFINITY) {
//            Ray.Origin = Ray.Origin + Ray.Vector * ScatteringTime;
//
//            // Compute a local coordinate frame for the scattering event.
//            vec3 X, Y, Z = Ray.Vector;
//            ComputeCoordinateFrame(Z, X, Y);
//
//            // Sample a random scattering direction in the local frame.
//            float U1 = Random0To1();
//            float U2 = Random0To1();
//            vec3 Scattered = SampleDirectionHG(Medium.ScatteringAnisotropy, U1, U2);
//
//            // Transform the scattered ray into world space and set it as the extension ray.
//            Ray.Vector = normalize(X * Scattered.x + Y * Scattered.y + Z * Scattered.z);
//            Ray.Duration = INFINITY;
//
//            return;
//        }
//        // Otherwise, we hit the skybox.
//        else {
//            AddEmission(Path, SampleSkyboxRadiance(Ray, Lambda));
//            
//            Path.Weight = vec4(0.0);
//            return;
//        }
//    }

    if (Hit.Time == INFINITY) {
        AddEmission(Path, SampleSkyboxRadiance(Ray, Path.Lambda));
        Path.Weight = vec4(0.0);
        return;
    }

    // Incoming ray direction in normal/tangent space.
    vec3 In;

    // Outgoing ray direction in normal/tangent space.
    vec3 Out = -vec3(
        dot(Ray.Vector, Hit.TangentX),
        dot(Ray.Vector, Hit.TangentY),
        dot(Ray.Vector, Hit.Normal));

    // Determines if the surface we hit is a virtual surface.  A surface
    // is virtual if it belongs to a shape with a lower priority than the
    // highest priority shape that we are currently traversing through.
    // In that case the medium associated with the higher priority shape
    // supersedes the lower priority one, and it is as if an interface
    // does not exist at that point at all.
    bool IsVirtualSurface = false;

    // Indices of refraction of the medium above the surface, per wavelength.
    vec4 ExteriorIOR = vec4(1.0);

//    if (Out.z > 0) {
//        // If we are hitting the exterior side of a shape, then the surface
//        // interface should affect the ray if the surface belongs to
//        // a higher priority shape than we are currently traversing through.
//        IsVirtualSurface = Medium.ShapePriority >= Hit.ShapePriority;
//
//        if (!IsVirtualSurface) {
//            ExteriorIOR = Medium.IOR;
//        }
//    }
//    else {
//        // If we are hitting the interior side of a shape, then the surface
//        // interface should affect the ray only if the surface belongs to
//        // the highest-priority shape that we are currently traversing
//        // through.
//        IsVirtualSurface = Medium.ShapeIndex != Hit.ShapeIndex;
//
//        // If the surface is real, then we need to determine the ambient IOR.
//        if (!IsVirtualSurface) {
//            // The medium beyond the surface will be that of the highest
//            // priority shape other than the one we are currently in.
//            medium Exterior = Ambience;
//            for (int I = 0; I < MAX_MEDIUM_COUNT; I++) {
//                if (Path.Mediums[I].ShapeIndex == SHAPE_INDEX_NONE)
//                    continue;
//                if (Path.Mediums[I].ShapeIndex == Medium.ShapeIndex)
//                    continue;
//                if (Path.Mediums[I].ShapePriority < Exterior.ShapePriority)
//                    continue;
//                Exterior = Path.Mediums[I];
//            }
//            ExteriorIOR = Exterior.IOR;
//        }
//    }

    // Resolve the surface and medium details.
    surface Surface;
    medium Interior;
    ResolveSurfaceHit(Hit, Path.Lambda, ExteriorIOR, Surface, Interior);


    // Pass through the surface if embedded in a higher-priority
    // medium, or probabilistically based on geometric opacity.
    if (Random0To1() > Surface.Opacity || IsVirtualSurface)
        In = -Out;
    else
        BSDF(Surface, Path.Lambda, Out, In, Path);

    if (max4(Path.Weight) < EPSILON) return;

//    // If the incoming and outgoing directions are within opposite hemispheres,
//    // then the ray is crossing the material interface boundary.  We need to
//    // perform bookkeeping to determine the current Medium.
//    if (In.z * Out.z < 0) {
//        if (Out.z > 0) {
//            // We are tracing into the object, so add a medium entry
//            // associated with the object.
//            for (int I = 0; I < MAX_MEDIUM_COUNT; I++) {
//                if (Path.Mediums[I].ShapeIndex == SHAPE_INDEX_NONE) {
//                    Path.Mediums[I] = Interior;
//                    break;
//                }
//            }
//        }
//        else {
//            // We are tracing out of the object, so remove the medium
//            // entry associated with the object.
//            for (int I = 0; I < MAX_MEDIUM_COUNT; I++) {
//                if (Path.Mediums[I].ShapeIndex == Hit.ShapeIndex) {
//                    Path.Mediums[I].ShapeIndex = SHAPE_INDEX_NONE;
//                    break;
//                }
//            }
//        }
//    }

    // Handle probabilistic termination.
    if (Random0To1() < RenderTerminationProbability) {
        Path.Weight = vec4(0.0);
        return;
    }

    Path.Weight *= 1.0 - RenderTerminationProbability;

    // Prepare the extension ray.
    Ray.Vector = In.x * Hit.TangentX
               + In.y * Hit.TangentY
               + In.z * Hit.Normal;

    Ray.Origin = Hit.Position + 1e-3 * Ray.Vector;

    Ray.Duration = INFINITY;
}

void RenderBaseColor(inout path Path, ray Ray, hit Hit, bool IsShaded)
{
    Path.Weight = vec4(0.0);

    if (Hit.Time == INFINITY) {
        // We hit the skybox.  Generate a color sample from the skybox radiance
        // spectrum by integrating against the standard observer.
        vec4 Spectrum = SampleSkyboxSpectrum(Ray);
        Path.Sample += ObserveParametricSpectrumSRGB(Spectrum);
        return;
    }

    // We hit a surface.  Resolve the base color sample from the reflectance
    // spectrum by integrating against the standard observer.
    packed_material Material = Materials[Hit.MaterialIndex];
    vec3 BaseColor = ObserveParametricSpectrumSRGB(Material.BaseSpectrum);
    if (Material.BaseSpectrumTextureIndex != TEXTURE_INDEX_NONE) {
        vec4 Value = SampleTexture(Material.BaseSpectrumTextureIndex, Hit.UV);
        BaseColor *= ObserveParametricSpectrumSRGB(Value.xyz);
    }

    if (IsShaded) {
        float Shading = dot(Hit.Normal, -Ray.Vector); 
        if (Hit.ShapeIndex == SelectedShapeIndex)
            BaseColor.r += 1.0;
        BaseColor *= Shading;
    }

    Path.Sample += BaseColor;
}

void main()
{
    // Initialize random number generator.
    RandomState
        = gl_GlobalInvocationID.y * 65537
        + gl_GlobalInvocationID.x
        + RandomSeed * 277803737u;

    if (gl_GlobalInvocationID.x >= 2048) return;
    if (gl_GlobalInvocationID.y >= 1024) return;

    uint Index
        = gl_WorkGroupID.y * 16 * 16 * (2048 / 16)
        + gl_WorkGroupID.x * 16 * 16
        + gl_LocalInvocationID.y * 16
        + gl_LocalInvocationID.x;

    if ((RenderFlags & RENDER_FLAG_RESET) != 0) {
        ivec2 ImagePosition = ivec2(gl_GlobalInvocationID.xy);
        GenerateNewPath(Index, ImagePosition);
        imageStore(SampleAccumulatorImage, ImagePosition, vec4(0.0));
        return;
    }

//    if (RenderMode == RENDER_MODE_PATH_TRACE)
//        RenderPathTrace();
//    else if (RenderMode == RENDER_MODE_BASE_COLOR)
//        RenderBaseColor(false);
//    else if (RenderMode == RENDER_MODE_BASE_COLOR_SHADED)
//        RenderBaseColor(true);
//    else if (RenderMode == RENDER_MODE_NORMAL)
//        SampleRadiance = RenderNormal(Ray);
//    else if (RenderMode == RENDER_MODE_MATERIAL_INDEX)
//        SampleRadiance = RenderMaterialIndex(Ray);
//    else if (RenderMode == RENDER_MODE_PRIMITIVE_INDEX)
//        SampleRadiance = RenderPrimitiveIndex(Ray);
//    else if (RenderMode == RENDER_MODE_MESH_COMPLEXITY)
//        SampleRadiance = RenderMeshComplexity(Ray);
//    else if (RenderMode == RENDER_MODE_SCENE_COMPLEXITY)
//        SampleRadiance = RenderSceneComplexity(Ray);

    ray Ray = LoadTraceRay(Index);
    hit Hit = LoadTraceHit(Index);
    path Path = LoadPath(Index);

    switch (RenderMode) {
        case RENDER_MODE_PATH_TRACE:
            RenderPathTrace(Path, Ray, Hit);
            break;
        case RENDER_MODE_BASE_COLOR:
            RenderBaseColor(Path, Ray, Hit, false);
            break;
        case RENDER_MODE_BASE_COLOR_SHADED:
            RenderBaseColor(Path, Ray, Hit, true);
            break;
        default:
            Path.Weight = vec4(0.0);
            break;
    }

    if (max4(Path.Weight) < EPSILON) {
        ivec2 ImagePosition = Path.ImagePosition;

        vec4 ImageValue = vec4(Path.Sample, 1.0);

        if ((RenderFlags & RENDER_FLAG_ACCUMULATE) != 0)
            ImageValue += imageLoad(SampleAccumulatorImage, ImagePosition);

        imageStore(SampleAccumulatorImage, ImagePosition, ImageValue);

        GenerateNewPath(Index, ImagePosition);
    }
    else {
        StoreTraceRay(Index, Ray);
        StorePathVertexData(Index, Path);
    }
}
